/**
 * release.mjs — Release management: Jira versions, release notes, GitHub Release.
 *
 * Functions receive `config` as first parameter.
 */

import { execFileSync } from "child_process";
import { log, logError } from "./log.mjs";
import {
  jiraFetch, listVersions, createVersion, releaseVersion, setFixVersion,
} from "./jira.mjs";
import { git } from "./git.mjs";
import { findPage, createPage, updatePage, buildStorageFormat } from "./confluence.mjs";

// ─── Find tickets for release ───────────────────────────────────────────────

async function findReleaseTickets(config) {
  const jql = encodeURIComponent(
    `project=${config.projectKey} AND status=${config.statuses.DONE} AND fixVersion is EMPTY ORDER BY created ASC`
  );
  const data = await jiraFetch(
    config,
    `/rest/api/3/search/jql?jql=${jql}&maxResults=200&fields=summary,issuetype,parent`
  );
  return data.issues || [];
}

// ─── Generate release notes markdown ────────────────────────────────────────

function generateReleaseNotes(versionName, tickets) {
  const grouped = { feat: [], fix: [], chore: [] };
  for (const issue of tickets) {
    const type = issue.fields.issuetype?.name || "Task";
    if (type === "Bug") grouped.fix.push(issue);
    else if (type === "Story" || type === "Task") grouped.feat.push(issue);
    else grouped.chore.push(issue);
  }

  const lines = [`# ${versionName}`, ""];
  if (grouped.feat.length > 0) {
    lines.push("## Features", "");
    for (const t of grouped.feat) lines.push(`- ${t.key}: ${t.fields.summary}`);
    lines.push("");
  }
  if (grouped.fix.length > 0) {
    lines.push("## Bug Fixes", "");
    for (const t of grouped.fix) lines.push(`- ${t.key}: ${t.fields.summary}`);
    lines.push("");
  }
  if (grouped.chore.length > 0) {
    lines.push("## Other", "");
    for (const t of grouped.chore) lines.push(`- ${t.key}: ${t.fields.summary}`);
    lines.push("");
  }
  lines.push(`---`, `${tickets.length} tickets | Generated by autodev`);
  return lines.join("\n");
}

// ─── Auto-detect next version ───────────────────────────────────────────────

function detectNextVersion(config) {
  const prefix = config.release?.tagPrefix || "v";
  try {
    const lastTag = git(config, `describe --tags --abbrev=0 --match "${prefix}*"`);
    const versionPart = lastTag.replace(prefix, "");
    const parts = versionPart.split(".").map(Number);
    parts[parts.length - 1]++;
    return prefix + parts.join(".");
  } catch {
    return prefix + "1.0.0";
  }
}

// ─── Create GitHub Release ──────────────────────────────────────────────────

function createGitHubRelease(config, tag, notes) {
  log(`Creating GitHub Release: ${tag}...`);
  const url = execFileSync(
    "gh",
    ["release", "create", tag, "--repo", config.ghRepo, "--title", tag, "--notes-file", "-"],
    { cwd: config.repoPath, encoding: "utf-8", input: notes, timeout: 30000 }
  ).trim();
  log(`GitHub Release created: ${url}`);
  return url;
}

// ─── Publish changelog to Confluence ────────────────────────────────────────

async function publishChangelog(config, versionName, notes) {
  const pageId = config.release?.confluenceChangelogPageId;
  if (!pageId && !config.confluence?.spaceKey) return null;

  const storageBody = buildStorageFormat(notes);

  try {
    if (pageId) {
      await updatePage(config, pageId, { body: storageBody, appendMode: true });
      return pageId;
    }
    // Create new changelog page
    const page = await createPage(config, {
      title: `Changelog — ${config.projectKey}`,
      body: storageBody,
    });
    return page.url;
  } catch (e) {
    logError(`Changelog publish failed: ${e.message}`);
    return null;
  }
}

// ─── Main orchestrator ──────────────────────────────────────────────────────

export async function performRelease(config, { version, auto = false, dryRun = false }) {
  const versionName = auto ? detectNextVersion(config) : version;
  if (!versionName) throw new Error("No version specified and auto-detect failed");

  log(`=== Release ${versionName} ===`);

  // 1. Find tickets
  const tickets = await findReleaseTickets(config);
  log(`${tickets.length} tickets to release`);

  if (tickets.length === 0) {
    log("No unreleased tickets found. Exiting.");
    return null;
  }

  // 2. Generate release notes
  const notes = generateReleaseNotes(versionName, tickets);

  if (dryRun) {
    log("DRY RUN — Release preview:");
    console.log(notes);
    return { versionName, ticketCount: tickets.length, notes };
  }

  // 3. Create Jira version (if not exists)
  const existing = await listVersions(config);
  let jiraVersion = existing.find((v) => v.name === versionName);
  if (!jiraVersion) {
    jiraVersion = await createVersion(config, {
      name: versionName,
      releaseDate: new Date().toISOString().split("T")[0],
    });
  }

  // 4. Assign fixVersion to all tickets
  for (const issue of tickets) {
    await setFixVersion(config, issue.key, versionName);
  }
  log(`Assigned fixVersion to ${tickets.length} tickets`);

  // 5. Create git tag + GitHub Release
  const releaseUrl = createGitHubRelease(config, versionName, notes);

  // 6. Publish to Confluence
  const confluenceUrl = await publishChangelog(config, versionName, notes);
  if (confluenceUrl) log(`Changelog published: ${confluenceUrl}`);

  // 7. Mark version as released
  await releaseVersion(config, jiraVersion.id);

  log(`=== Release ${versionName} complete ===`);
  return { versionName, ticketCount: tickets.length, releaseUrl, confluenceUrl };
}
